# -*- coding: utf-8 -*-
"""
Partie statistiques et probobilité du module lycee.
"""
"""
Créé à partir d' Edupython: http://edupython.tuxfamily.org/

Licence CECILL http://www.cecill.info/
"""

import math
import builtins
from arithmetique import quotient
import random

# Loi Binomial
def binomial(n, p):
    """
    Renvoie un entier (int) représentant le coefficient binomial ``p`` parmi ``n``.

    C'est à dire le nombre de chemins de l’arbre réalisant ``p`` succès pour ``n`` répétitions.

    Arguments:
        n (int): Un nombre entier
        p (int): Un nombre entier
    """
    if p <= n:
        return quotient(
            math.factorial(n),
            math.factorial(n-p+1) * math.factorial(p)
        )
    else:
        return 0


def tirage_binomial(n, p):
    """
    Renvoie un nombre entier (int) choisi de manière aléatoire selon une loi binomiale B(n,p) : ``p`` parmi ``ǹ``.

    Arguments:
        n (int): Premier paramètre de la loi binomiale à simuler.
        p (int): Second paramètre de la loi binomiale à simuler.
    """
    s = 0
    for i in range(n):
        if alea() < p:
            s = s + 1
    return s

# Loi uniforme
def alea_entier(min, max):
    """
    Renvoie un entier (int) choisi de manière (pseudo)aléatoire et équiprobable
    dans l'intervalle [``min`` ; ``max``].

    Arguments:
        min (int): Un nombre entier
        max (int): Un nombre entier
    """
    return random.randint(min, max)

def tirage_uniforme(min, max):
    """
    Renvoie un nombre décimal (float) choisi de manière (pseudo)aléatoire et uniforme
    de l'intervalle \[``min`` ; ``max``\[.

    Arguments:
        min (float): Un nombre réel.
        max (float): Un nombre réel.

    """
    return random.uniform(min, max)

def choix(liste):
    """
    Renvoie un élément de la liste ``liste`` choisi (pseudo)aléatoirement et de manière équipropable

    Arguments:
        liste (int): La liste dans laquelle on choisit un élément.
    """
    return random.choice(liste)


def alea():
    """
    Renvoie au hasard un décimal de l'intervalle [0 ; 1[
    """
    return random.random()

# Loi exponentielle

def tirage_expo(x):
    """
    Renvoie un nombre décimal (float) choisi de manière aléatoire selon
    une loi exponentielle de paramètre ``x``.

    Arguments:
        x (float) : est un réel strictement positif.
    """
    return random.expovariate(x)

# Loi normale

def tirage_normale(mu, sigma):
    """
    Renvoie un nombre décimal (float) choisi de manière aléatoire
    selon une loi nomale d'espérance ``mu`` et d'écart type ``sigma``.

    Arguments:
        mu (float): Un nombre décimal. L'éspérance de la loi normale
        sigma (float): Un nombre décimal. L'écart type de la loi normale
    """
    return random.gauss(mu, sigma)


def normal_frep(a, b, mu, sigma):
    """
    Renvoie un nombre décimal (float) représentant une estimation de la probabilité P(``a`` < X < ``b``)
    lorsque X suit une loi normale d'espérance ``mu`` et d'écart type ``sigma``.

    Arguments:
        a (float): Un nombre décimal
        b (float): Un nombre décimal
        mu (float): Un nombre décimal. L'espérance de la loi normale
        sigma (float): Un nombre décimal. L'écart type de la loi normale
    """
    if a < b:
        return norm.cdf(b, mu, sigma) - norm.cdf(a, mu, sigma)
    else:
        return 0


def intervalle(debut, fin, pas=1):
    """
    Renvoie une liste d’entiers de ``deb`` à ``fin`` avec un pas de ``pas``.

    Arguments:
        deb (int): Le début de l'intervalle
        fin (int): La fin de l'intervalle
        pas (int, optionnel): Le pas (``1`` par défaut).
    """
    return builtins.range(debut, fin + 1, pas)


def compte(liste, option='optionnel'):
    """
    Retourne la liste triée sans les doublons et
    – Si l'option est "effectif", la liste est retournée avec les effectifs des valeurs.
    – Si l'option est "frequence", la liste est retournée avec les fréquences des valeurs.

    Arguments:
        liste (list): une liste de nombres
        option (str, optionnel): "frequence" ou "frequences" ou "effectif" ou "effectifs"
    """
    def divliste(x):  # Définition de la fonction pour diviser par l'effectif total
        return x / len(liste)
    # On trie la liste pour rencontrer les éléments par ordre croissant.
    liste = sorted(liste)
    # Initialise la liste des valeurs avec la première valeur
    listf = [liste[0]]
    # Initialise la liste des effectifs avec le premier effectif associé
    eff = [liste.count(liste[0])]
    for i in range(len(liste)):  # On parcourt la série
        if liste[i] not in listf:
            # Si l'élément n'a pas encore été rencontré, il est ajouté à la
            # liste.
            listf.append(liste[i])
            # Ajoute à la liste des effectifs, l'effectif associé à cette
            # nouvelle valeur
            eff.append(liste.count(liste[i]))
    if option == 'effectif' or option=='effectifs':
        return sorted(listf), eff
    elif option == 'frequence' or option == 'frequences':
        # Calcul des fréquences par division par l'effectif total.
        return sorted(listf), list(map(divliste, eff))
    else:
        return sorted(listf)

# Les classes
def centres(L):  # Pourquoi?
    """
    Renvoie une liste de longueur n-1 contenant les valeurs (L[i]+L[i+1])/2.

    Arguments:
        L (list): Une liste de taille n
    """
    R = []
    for i in range(len(L) - 1):
        R.append((L[i] + L[i + 1]) / 2)
    return R

#
# def ECC(xi, ni='optionnel'):
#     """
#     Génère les effectifs cumulés croissants de la liste ``xi``.
#
#     Arguments:
#         xi (list): liste de valeurs
#         ni (list, optionnel): liste des effectifs associés
#     """
#     if ni == 'optionnel':
#         xi, ni = compte(xi, 'effectif')
#     T = 0
#     E = []
#     for i in range(len(ni)):
#         T = T + ni[i]
#         E.append(T)
#     return xi, E
#

# def FCC(xi, ni='optionnel'):
#     """
#     Génère les fréquences cumulées croissantes de la liste ``xi``.
#
#     Arguments:
#         xi (list): Une liste de valeurs
#         ni (list, optionnel): La liste des effectifs associés
#     """
#     xi, ni = ECC(xi, ni)
#     for i in range(len(ni)):
#         ni[i] = ni[i] / ni[len(ni) - 1]
#     return xi, ni
#
#
# def polygoneECC(xi, ni='optionnel', couleur='b'):
#     """
#     Génére le polygone des Effectifs Cumulés Croissants de la liste.
#
#     Arguments:
#         xi (list): une liste de valeurs
#         ni (list, optionel): la liste des effectifs associés.
#         couleur (str, optionnel): couleur du polygone ('b'=bleue par défaut)
#
#     """
#     xi, ec = ECC(xi, ni)
#     if len(xi) == len(ec) + 1:
#         ec.insert(0, 0)
#         repere.plot(xi, ec, couleur + 'o')
#         repere.plot(xi, ec, couleur)
#         repere.title('Polygone des Effectifs Cumules Croissants')
#         repere.ylabel('Effectifs')
#         repere.xlabel('Valeurs de la liste')
#
#
# def polygoneFCC(xi, ni='optionnel', couleur='b'):
#     """
#     Génére le polygone des fréquences cumulées croissantes de la liste ``xi``.
#
#     Arguments:
#         xi (list): liste de valeurs.
#         ni (list, optionnel): liste des effectifs
#         couleur (str, optionnel): couleur de graphique ('b'=bleue par défaut)
#     """
#     xi, ec = FCC(xi, ni)
#     if len(xi) == len(ec) + 1:
#         ec.insert(0, 0)
#         repere.plot(xi, ec, couleur + 'o')
#         repere.plot(xi, ec, couleur)
#         repere.title("Polygone des Frequences Cumulees Croissantes")
#         repere.ylabel('Frequences')
#         repere.xlabel('Valeurs de la liste')
#

def moyenne(xi, ni='optionnel'):
    """
    Renvoie la moyenne de la liste ``xi``.

    Arguments:
        xi (list): liste de valeurs (ou les extrémité des classes)
        ni (liste, optionnel): série des effectifs associés
    """
    if ni == 'optionnel':
        xi, ni = compte(xi, 'effectif')
    if len(xi) == len(ni) + 1:
        xi = centres(xi)  # Si on travaille avec des classes
    s = 0
    # print xi,ni
    for i in range(len(xi)):
        s = s + xi[i] * ni[i]
    return s / sum(ni)

# Les fonctions suivantes utilisent un fonction mistérieuse trier_liste.

# def mediane(xi, ni='optionnel', option='optionel'):  # confus, à refaire
#     """
#     Renvoie la médiane de la liste ``xi``.
#
#     - L'option par défaut est l'option 1.
#     - Si l'option est 1, la médiane est la valeur centrale (valeur de la série ou moyenne arithmétique)
#     - Si l'option est 2, la médiane est la valeur pour laquelle on dépasse 50% des valeurs.
#
#     Arguments:
#         xi (list): Liste de valeurs
#         ni (list, optionel): Liste des effectifs associés
#         option (int, optionel):  1 ou 2
#     """
#     if ni == 'optionnel':  # On vérifie si ni existe
#         xi, ni = compte(xi, 'effectif')
#     elif ni == 2 or ni == 1:  # On vérifie si option existe
#         option = ni
#         xi, ni = compte(xi, 'effectif')
#     else:  # ni existe, on vérifie si xi est ordonnée sinon on trie xi et ni
#         if xi != sorted(xi) and isinstance(ni, list):
#             xi, ni = trier_liste(xi, ni)
#     i = 0
#     k = ni[0]
#     while k < sum(ni) / 2:
#         i = i + 1
#         k = k + ni[i]
#     if option == 2:  # Option 2
#         if k <= sum(ni) / 2:
#             return xi[i + 1]
#         else:
#             return xi[i]
#     else:  # Option 1 par défaut
#         if sum(ni) / 2 == int(sum(ni) / 2):
#             if k <= sum(ni) / 2:
#                 return (xi[i] + xi[i + 1]) / 2
#             else:
#                 return xi[i]
#         else:
#             if k <= sum(ni) / 2:
#                 return xi[i + 1]
#             else:
#                 return xi[i]
#
#
# def quartile(xi, ni='optionnel', valeur='optionnel'):  # confus, il est plus simple de retourner une liste de 3 valeurs
#     """
#     Retourne les quartiles de la liste.
#
#     - Si valeur=1, retourne le premier quartile.
#     - Si valeur=3, retourne le troisième quartile.
#     - Par défaut, le premier et le troisième quartile sont retournés
#
#     Arguments:
#         xi (list): Une série de valeurs
#         ni (list, optionel): Liste des effectifs associés
#         valeur (int, optionel):  le quartile que l'on souhaite 1 ou 3
#     """
#     if ni == 'optionnel':  # On vérifie si ni existe
#         xi, ni = compte(xi, 'effectif')
#     elif ni == 3 or ni == 1:  # On vérifie si valeur existe
#         valeur = ni
#         xi, ni = compte(xi, 'effectif')
#     else:  # ni existe, on vérifie si xi est ordonnée sinon on trie xi et ni
#         if xi != sorted(xi) and isinstance(ni, list):
#             xi, ni = trier_liste(xi, ni)
#     q1pos = int(sum(ni) / 4)  # On définit la position de q1
#     q3pos = int(3 * sum(ni) / 4)  # On définit la position de q3
#     k = 0
#     i = 0
#     while k < q1pos:  # On cherche q1
#         k = k + ni[i]
#         i = i + 1
#     q1 = xi[i]  # On définit q1
#     while k < q3pos:  # On cherche q3
#         k = k + ni[i]
#         i = i + 1
#     q3 = xi[i]  # On définit q3
#     if valeur == 1:  # Affichage du 1er quartile
#         return q1
#     if valeur == 3:  # Affichage du 3ème quartile
#         return q3
#     if valeur != 1 and valeur != 3:  # Option par défaut
#         return q1, q3
#
#     q1 = xi[int(len(xi) / 4)]  # c'est quoi ca?
#     q3 = xi[int(3 * len(xi) / 4)]
#     if valeur == 1:
#         return q1
#     elif valeur == 3:
#         return q3
#     else:
#         return q1, q3
#
#
# def decile(xi, ni='optionnel', valeur='optionnel'):  # Idem retourner une liste de 9 valeurs
#     """
#     Retourne les déciles de la liste.
#
#     - Si valeur=1, retourne le premier décile.
#     - Si valeur=9, retourne le neuvième décile.
#     - Par défaut, le premier et le neuvième décile sont retournés
#
#     Arguments:
#         xi (list): Liste de valeurs
#         ni (list, optionel): Liste des effectifs associés
#         valeur (int, optionel): le decile que l'on souhaite 1 ou 9
#     """
#     if ni == 'optionnel':  # On vérifie si ni existe
#         xi, ni = compte(xi, 'effectif')
#     elif ni == 9 or ni == 1:  # On vérifie si valeur existe
#         valeur = ni
#         xi, ni = compte(xi, 'effectif')
#     else:  # ni existe, on vérifie si xi est ordonnée sinon on trie xi et ni
#         if xi != sorted(xi) and isinstance(ni, list):
#             xi, ni = trier_liste(xi, ni)
#
#     d1pos = int(sum(ni) / 10)  # On définit la position de d1
#     d9pos = int(9 * sum(ni) / 10)  # On définit la position de d9
#     k = 0
#     i = 0
#     while k < d1pos:  # On cherche d1
#         k = k + ni[i]
#         i = i + 1
#     d1 = xi[i]  # On définit d1
#     while k < d9pos:  # On cherche d19
#         k = k + ni[i]
#         i = i + 1
#     d9 = xi[i]  # On définit d9
#     if valeur == 1:  # Affichage du 1er décile
#         return d1
#     if valeur == 9:  # Affichage du 9eme décile
#         return d9
#     if valeur != 1 and valeur != 9:  # Option par défaut
#         return d1, d9


def variance(xi, ni='optionnel'):
    """
    Retourne la variance de la liste.

    Arguments:
        xi (list): Liste de valeurs (ou les extrémité des classes)
        ni (list, optionnel): Liste des effectifs associés
    """
    if not isinstance(ni, list):
        xi, ni = compte(xi, 'effectif')
    if len(xi) == len(ni) + 1:
        xi = centres(xi)  # Si on travaille avec des classes
    v = 0
    xbar = moyenne(xi, ni)
    for i in range(len(xi)):
        v = v + (xi[i] - xbar)**2 * ni[i]
    return v / (sum(ni))


def ecartype(xi, ni='optionnel'):
    """
    Retourne l'écart-type de la liste.

    Arguments:
        xi (list): Liste de valeurs (ou les extrémité des classes)
        ni (list, optionnel): Liste des effectifs associés
    """
    return math.sqrt(variance(xi, ni))
