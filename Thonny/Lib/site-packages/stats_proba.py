def binomial(n, p):
    """
    Renvoie un entier (int) représentant le coefficient binomial     ``p`` parmi ``n``,
     c'est à dire le nombre de chemins de l’arbre réalisant ``p`` succès pour ``n`` répétitions.

    Arguments:
        n (int): Un nombre entier
        p (int): Un nombre entier
    """
    if p<=n :
        return quotient(math.factorial(n), math.factorial(p) * math.factorial(n - p))
    else :
        return 0

def tirage_binomial(n, p) :
    """
    Renvoie un nombre entier (int) choisi de manière aléatoire selon une loi
    binomiale B(n,p).

    Arguments:
        n (int): Premier paramètre de la loi binomiale à simuler.
        p (int): Second paramètre de la loi binomiale à simuler.
    """
    s = 0
    for i in range(n) :
        if random()<p :
            s = s + 1
    return s

def alea_entier(min, max):
    """
    Renvoie un entier (int) choisi de manière (pseudo)aléatoire et équiprobable
     dans l'intervalle [min,max].

    Arguments:
        min (int): Un nombre entier
        max (int): Un nombre entier
    """
    return alea.randint(min,max)

def choix(liste): # notion de liste au lycée ?
    """
    Renvoie un élément de la liste ``liste`` choisi (pseudo)aléatoirement et
     de manière équipropable

    Arguments:
        liste (int): La liste dans laquelle on choisit un élément.
    """
    return alea.choice(liste)

def alea():
    """
    Renvoie au hasard un décimal de l'intervalle [0;1[
    """
    return alea.random()

def expovariate(l):
    """
    Renvoie un nombre décimal (float) choisi de manière aléatoire selon
    une loi exponentielle de paramètre ``l``.

    Arguments:
        l est un réel strictement positif.
    """
    return alea.expovariate(l)


def gauss(mu, sigma):
    """
    Renvoie un nombre décimal (float) choisi de manière aléatoire
    selon une loi nomale d'espérance ``mu`` et d'écart type ``sigma``.

    Arguments:
        mu (float): Un nombre décimal. L'éspérance de la loi normale
        sigma (float): Un nombre décimal. L'écart type de la loi normale
    """
    return alea.gauss(mu,sigma)


def normal_frep(a, b, mu, sigma):
    """
    Renvoie un nombre décimal (float) représentant une estimation de la probobilité P(``a`` < X < ``b``)
    lorsque X suit une loi normale d'espérance ``mu`` et d'écart type ``sigma``.

    Arguments:
        a (float): Un nombre décimal
        b (float): Un nombre décimal
        mu (float): Un nombre décimal. L'éspérance de la loi normale
        sigma (float): Un nombre décimal. L'écart type de la loi normale
    """
    if a < b :
        return norm.cdf(b,mu,sigma) - norm.cdf(a,mu,sigma)
    else :
        return 0

def inv_norm(k, mu, sigma):
    """
    Renvoie la valeur du réel x (float) telle que  P(X < x) = ``k``
    lorsque X suit une loi normale d'espérance ``mu`` et d'écart type ``sigma``.

    Arguments:
        k (float): Un nombre décimal
        mu (float): Un nombre décimal. L'éspérance de la loi normale
        sigma (float): Un nombre décimal. L'écart type de la loi normale
    """
    return norm.ppf(k,mu,sigma)

def uniforme(min,max):
    """
    Renvoie un nombre décimal (float) choisi de manière (pseudo)aléatoire et
    uniforme de l'intervalle [``min``,``max``[.

    Arguments:
        min (float): Un nombre décimal
        max (float):res.

    """
    return alea.uniform(min,max)

def intervalle(debut,fin,pas='optionel'):
    """
    debut, fin et pas sont des entiers.
    Le paramètre pas est optionnel.
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Renvoie une liste d’entiers :
      – De l’intervalle [deb; fin] si 2 paramètres sont renseignés
      – De l’intervalle [deb; fin] mais en réalisant une suite arithmétique de raison pas si les 3 paramètres sont renseignés.
    """
    if pas=='optionel':
        return builtins.range(debut,fin+1)
    else :
        return builtins.range(debut,fin+1,pas)
